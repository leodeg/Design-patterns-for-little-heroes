# SOLID



## Принцип единственной ответственности (single responsibility principle)

> Класс должен иметь одну и только одну причину для изменения.
>
> Роберт Мартин

Данный принцип означает, что класс должен решать определенную проблему и эта проблема должна быть единственной причиной для изменения.

К примеру, в игре у персонажа есть статы, и чтобы не потерять набранный опыт необходимо сохранить информацию в файл.

```c#
struct Stats {
    public string name;
    public int gold;
    public double experience;
}

class Player {
    private Stats stats;

    public Player (Stats stats) {
        this.stats = stats;
    }

    public void SaveStatsToFile (string path) {
        // Save to file...
    }
}
```

В данном примере класс **Player** отвечает за информацию игрока и за ее сохранение. 

Информацию можно сохранять в JSON формат, можно в XML формат или в любой другой. Так как вариантов может быть много, правильным решением будет вынести ответственность за сохранение в отдельный класс.

```c#
struct Stats {
    public string name;
    public int gold;
    public double experience;
}

class Player {
    private Stats stats;

    public Player (Stats stats) {
        this.stats = stats;
    }

    public Stats GetStats () {
        return stats;
    }
}

class StatsWriter { // Отвечает только за запись
    public void WriteStatsToJSON (Stats stats, string path) {
        // Save to file...
    }

    public void WriteStatsToXML (Stats stats, string path) {
        // Save to file...
    }
}

class StatsReader { // Отвечает только за чтение
    public Stats ReadStatsFromJSON (string path) {
        // Read from file...
        throw new NotImplementedException ();
    }

    public Stats ReadStatsFromXML (string path) {
        // Read from file...
        throw new NotImplementedException ();
    }
}
```

В примере обязанность чтения и записи разделена на два класса - **StatsReader** и **StatsWriter**. Данный классы можно спокойно расширять не трогая класс **Player**.

В данном случае классы решают схожие задачи (только чтение, только запись), одного определенного пользователя (класса Stats).

Принцип единной ответственности не означает, что класс должен содержать только один метод. Главное, чтобы они были направлены на решения одной задачи.

В книге "Чистая Архитектура", Роберт Мартин рассматривает данный прицип на компонентах/сборках (dll, jar, gem). Один компонент должен быть направлен на решения задач связанных с одним пользователем.

> Модуль должен отвечать за одного и только за одного пользователя или заинтересованное лицо.  
>
> Чистая архитектура - Роберт Мартин

К примеру, есть платформа для введения предприятия. Компонент отвечающих за бухгалтерию должен решать проблемы только связанные с бугалтерией. Компонент складского учёта должен решать только проблемы по введению склада и так далее.

## Принцип открытости/закрытости (open–closed principle)

> Сущности (классы, модули, функции...) должны быть открыты для расширения и закрыти для изменения.
>
> Бертран Мейер



## Принцип подстановки Лисков (Liskov substitution principle)

> 

> Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.
>
> Роберт Мартин



## Принцип разделения интерфейса (interface segregation principle)

> **Программные сущности** не должны зависеть от методов, которые они не используют.
>
> Роберт Мартин





## Принцип инверсии зависимостей (dependency inversion principle)

> - Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
> - Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
>
> 

## Дополнительный материал

1. Чистая Архитектура - Роберт Мартин
2. [Простое объяснение принципов SOLID - Хабр](https://habr.com/ru/company/mailru/blog/412699/) 
3. [Принципы SOLID в C# - Proffesorweb](https://professorweb.ru/my/it/blog/net/solid.php)
4. [Принципы SOLID C# - CodeBlog](https://shwanoff.ru/solid-c-sharp/)