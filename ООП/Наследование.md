# Наследование

> Наследование (англ. inheritance) — концепция объектно-ориентированного программирования, согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения.
>
> [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

Наследование позволяет создавать новый класс на основе существующего и продолжать иерархию классов, давая дочернему классу все возможности родительского.

Класс от которого наследуются называют — родительским, предком или суперклассом. Класс, который наследуется от другого класса, называется — дочерним, производным, потомком, подклассом или подтипом.

```c#
class Parent {}
class Child : Parent {}
```

Наследование позволяет повторно использовать существующую реализацию и уменьшает дублирования кода, но это не единственная его задача. Кроме наследования есть и другие способы повторно использовать код, к примеру **агрегация** или **композиция**.

```c#
class Parent {}

// Композиция
class Child {
    private Parent parent;
    public Child () { 
        this.parent = new Parent(); 
    }
}
// Агрегация
class Child {
    private Parent parent;
    public Child (Parent parent) { 
        this.parent = parent; 
    }
}

```

Кроме повторного использования кода, в задачи наследования входят: **формирования иерархии родственных объектов**, в статических языках вроде C# или Java наследование открывает путь к **полиморфизму**.

## Почему наследование считается опасным?

Когда ООП стало популярным был этап, когда наследование использовалось повсюду. Разработчики создавали запутанные иерархии классов в которых было сложно разобраться. 

Минус наследования в том, что оно создает слишком сильное **связывание классов**. Связывание означает, что изменения одного класса повлияет на работу другого класса. Если у родительского класса сотни дочерних, то его изменения может привести к странному поведению всех его подклассов. К примеру в родительском может быть удаленно поле или метод, который используется в дочерних, соответственно придется вносить изменения в дочерние классы. Это одна из причин, почему наследование считается вредным.

А еще хуже, что в языках которые позволяют множественное наследование, вроде C++, могут быть случаи, когда один класс наследуется от родительского несколько раз. 

```c++
// Пример множественного наследования
class Parent {}
class ChildA : Parent {}
class ChildB : Parent {}
class Grandson : ChildA, ChildB {}
```

Разработчики пришли к выводу — чрезмерно использовать наследование слишком опасно. Однако, это привело к другой крайности: некоторые разработчики стали советовать не использовать наследование совсем, а вместо него советуют использовать композицию или агрегацию, причём их стали использовать даже там, где нужно явно использовать наследование.

Есть даже небольшая мантра: “*Предпочитайте композицию наследованию*”

Однако наследования и композиция являются разными отношениями между классами.

Наследование является отношением типа — **is a**; один объект является подтипом другого. К примеру: человек ***является*** млекопитающим, слон ***является*** животным, машина ***является*** транспортом, пистолет ***является*** оружием…

```c#
class Mammal {
    public void FeedMilk() {
        Console.WriteLine("Mammal:: Feed Milk");
    }
}

class Human : Mammal { }
```

Композиция и агрегация является отношением типа — **has a**; один объект включает в себя другой объект. К примеру: машина ***содержит в себе*** двигатель, человек ***содержит в себе*** внутренние органы, пистолет ***содержит в себе*** пули…

```C#
class Engine {
	public void Start() {
		Console.WriteLine("Engine:: Start");
    }
}

class Car {
    private Engine engine;
    
    public Car () {
        engine = new Engine();
    }
    
    public void Start() {
        engine.Start();
        Console.WriteLine("Car:: Start");
    }
}
```

Оба варианта позволяют повторно использовать код. Вот только цели у этих отношений совершенно разные.

## Когда использовать наследование?

Проблема в том, что без наследования в статических языках программирование многие вещи просто сделать не получится, особенно, когда дело касается приведения типов, а точнее полиморфизма. Хотя в динамических языках можно спокойно обойтись и без наследования.

### Проблема

Представим, что мы играем в онлайн ММОРПГ игру, наш персонаж класса — мечник. Из оружия кроме мечей он ничего не может использовать, и персонаж может использовать только один меч одновременно. В начале игры персонажу предоставляют стандартный меч для новобранца — DefaultSword.

```c#
class Slayer {
    private DefaultSword sword;
    
	public Slayer (DefaultSword sword) {
		ChangeSword (sword);
    }
    
    public void ChangeSword (DefaultSword sword) {
        this.sword = sword;
    }
    
    public double GetDamage () {
        return sword.GetDamage ();
    }
}

class DefaultSword {
    private double damage = 15;
    public double GetDamage () {
        return damage;
    }
}

class Program {
    static void Main (string[] args) {
        // В начале игры у персонажа стандартный меч
        Slayer slayer = new Slayer();
		Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Вывод на консоль:
        // Slayer damage:: 15
    }
}
```

По ходу игры мы убиваем мобов, из них выпадают новые вещи и для персонажа находится новый меч, к примеру “меч убийцы гоблинов”. Однако проблема в том, что метод ChangeSword принимает в аргументы только тип DefaultSword. В принципе можно создать новый метод, который будет принимать новый тип, а также новую переменную, которая будет его хранить. Учитываем, что персонаж может держать только один меч, если мы подбираем новый старый выбрасываем.

```c#
class Slayer {
    private DefaultSword defaultSword;
    private GoblinSlayerSword goblinSlayerSword;

	public Slayer () {
		ChangeSword (new DefaultSword());
    }
    
    public void ChangeSword (DefaultSword sword) {
        defaultSword = sword;
        goblinSlayerSword = null;
    }

	public void ChangeSword (GoblinSlayerSword sword) {
		goblinSlayerSword = sword;
        defaultSword = null;
    }

    public double GetDamage () {
        if (goblinSlayerSword != null)
            return goblinSlayerSword.GetDamage ();
        else if (defaultSword != null)
        	return defaultSword.GetDamage ();
        return 0;
    }
}

class DefaultSword {
    private double damage = 15;
    public double GetDamage () {
        return damage;
    }
}

class GoblinSlayerSword {
    private double damage = 25;
    public double GetDamage() {
        return damage;
    }
}

class Program {
    static void Main (string[] args) {
        // В начале игры у персонажа стандартный меч
        Slayer slayer = new Slayer();
		Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Нашли новый меч
        GoblinSlayerSword newSword = new GoblinSlayerSword();
        slayer.ChangeSword(newSword);
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Вывод на консоль:
        // Slayer damage:: 15
		// Slayer damage:: 25
    }
}
```

Размер класса резко вырос, а самое отвратительное, что в классе два одинаковых метода, которые делают почти одно и тоже. В методе GetDamage приходится дополнительно проверять, какой меч обмундирован из инвентаря, чтобы узнать сколько урона можно нанести. 

Но в игре может быть сотни видов мечей. А также может быть дополнительные типы в которые можно вставлять магические камни, для дополнительных эффектов, что еще сильнее раздует класс нашего персонажа, а дублирования кода станет еще больше.

### Решение

При помощи наследования можно создать иерархию схожих типов, в данном случае мечей. Так как “меч убийцы гоблинов ” и “стандартный меч” являются просто подвидами меча.

```c#
class Slayer {
    private Sword sword;
    
    public Slayer () {
        ChangeSword (new DefaultSword());
    }
    
    public void ChangeSword (Sword sword) {
        this.sword = sword;
    }
    
    public double GetDamage () {
        return sword.GetDamage();
    }
}

abstract class Sword {
    private double damage;
    
    protected void SetDamage (double damage) {
        this.damage = damage;
    }
    
    public double GetDamage () {
        return damage;
    }
}

class DefaultSword : Sword {
    public DefaultSword () {
        this.SetDamage (15);
    }
}

class GoblinSlayerSword : Sword {
    public GoblinSlayerSword () {
        this.SetDamage (25);
    }
}

class Program {
    static void Main (string[] args) {
        // В начале игры у персонажа стандартный меч
        Slayer slayer = new Slayer();
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Нашли новый меч
        GoblinSlayerSword newSword = new GoblinSlayerSword();
        slayer.ChangeSword (newSword);
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Вывод на консоль:
        // Slayer damage:: 15
		// Slayer damage:: 25
    }
}
```

Код в методе **Main** остался таким же и поведение классов не изменилось.  Вся основная логика осталась в **абстрактном** классе **Sword**,  а в дочерних классах при создании объекта указывается новый урон. В классе Slayer больше нет необходимости  проверять какой меч используется и какой урон возвращать, все это теперь инкапсулировано в отдельных классах. 

Sword объявлен абстрактным, так как является лишь шаблоном и нам не нужно создавать его экземпляр. При создании экземпляра абстрактного класса компилятор выкинет ошибку.

```c#
// Ошибка: нельзя создать экземпляр абстрактного класса
Sword sword = new Sword();
```

Благодаря наследованию можно легко добавить новый класс, к примеру с дополнительным уроном:

```c#
class FireSword : Sword {
    private double fireDamage = 15.0;
    public FireSword () {
        this.SetDamage (15.0 + fireDamage);
    }
}
```

```c#
class Program {
    static void Main (string[] args) {
        // В начале игры у персонажа стандартный меч
        Slayer slayer = new Slayer();
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Нашли новый меч
        GoblinSlayerSword newSword = new GoblinSlayerSword();
        slayer.ChangeSword (newSword);
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
        // Снова нашли новый меч
        FireSword fireSword = new FireSword();
        slayer.ChangeSword (fireSword);
        Console.WriteLine("Slayer damage:: " + slayer.GetDamage());
        
       	// Вывод на консоль:
       	// Slayer damage:: 15
		// Slayer damage:: 25
       	// Slayer damage:: 30
    }
}
```

Данный пример не только показывает наследование, но и полиморфизм. Так как неявное приведение типа **FireSword** к **Sword** является полиморфизмом. Без наследование, сделать бы это в статическом языке программирование как C#, было бы невозможно.

Как видно в примерах наследование решает проблему приведения типов.

## Итоги

- Наследование может использоваться для повторного использования кода.
- В статических языках программирования наследование решает проблему приведения типов и открывает путь к полиморфизму.
- Наследование необходимо использовать для создания иерархии схожих типов; когда один объект является подвидом другого объекта.
- Наследование незаслуженно порицается. При здравом использовании наследование может быть мощным инструментов, и в статических языках программирования без него не обойтись.
- Наследование является отношением типа  —“is a”, а композиция и агрегация — “has a”.
- Наследование, как и другие виды отношений, необходимо использовать там где нужно, а не там где можно.
