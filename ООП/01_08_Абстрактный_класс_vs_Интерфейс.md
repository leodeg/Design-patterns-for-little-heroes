# Абстрактный класс vs Интерфейс



> Класс называется **абстрактным**, если его единственное назначение — определить общий интерфейс для всех своих подклассов.
>
> —[Приемы объектно-ориентированного проектирования. Паттерны проектирования - GOF (глава 1.6, с. 29)](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)



> Множество сигнатур всех определенных для объекта операций называется **интерфейсом** этого объекта.
>
> — [Приемы объектно-ориентированного проектирования. Паттерны проектирования - GOF (глава 1.6, с. 27)](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional-ebook/dp/B000SEIBB8)

Абстрактный класс определяет общий интерфейс для родственных объектов, в то время как интерфейс является лишь набором определений открытых методов.

Интерфейс является лишь описанием поведения, но сам им не обладает. Абстрактный класс описывает поведение и в тоже время может обладать им.

## Абстрактный класс

Абстрактный класс — это класс в котором есть один или несколько нереализованных методов.

В ООП языках есть специальное слово для пометки абстрактных классов и методов —  **abstract**.

```c#
abstract class Sword {
	public abstract void SetDamage ();
    public abstract double GetDamage ();
}
```

### Пример

Практически в любой компьютерной игре есть существа и предметы, которые можно уничтожить. У таких объектов будет похожее поведение, к примеру: все они могут обладать очками жизни, анимацией и звуками при нанесении урона, дополнительной логикой при уничтожении, вроде обновление таблицы смертей.

```c#
public abstract class Damageable {
	private int hitPoints;
    
    protected void SetHitPoints (int hitPoints) {
        this.hitPoints = hitPoints;
    }
    
    public virtual void TakeDamage (int damage) {
        hitPoints -= damage;
        if (hitPoints <= 0)
            Death ();
    }
    
    public virtual void Heal (int healPoints) {
        hitPoints += healPoints;
    }
    
    public abstract void Death ();
}

public class Player : Damageable {
    private string name;
    public Player (string name, int hitPoints) {
        this.SetHitPoints (hitPoints);
        this.name = name;
    }
    public override void Death () {
        // Do something... (animation, sounds effects)
    }
}

public class Enemy : Damageable {
    private string name;
    public Enemy (string name, int hitPoints) {
        this.SetHitPoints (hitPoints);
        this.name = name;
    }
    public override void Death () {
        // Do something... (animation, sounds effects)
    }
}

public class DamageableItem : Damageable {
    public DamageableItem () {
        this.SetHitPoints (25);
    }
    public override void Death () {
        // Do something... (animation, sounds effects)
    }
}
```

Для всех объектов, которые можно будет уничтожить родительским классом станет абстрактный класс “Damageable”. Пока он только содержит логику для хит-поинтов. В дальнейшем можно будет добавить логику для анимации или звуков.

Абстрактный класс выступает в роли шаблона, который описывает интерфейс и предоставляет стандартное поведение. Некоторые методы стоит переопределить в дочерних классах. В данном случае метод “Death”. Его логика будет отличаться для живых существ и предметов. К примеру: при смерти врагов могут выпадать предметы и обновляться статистика игры, при смерти босса может начаться видео заставка и так далее.

### Ограничения абстрактного класса:

Нельзя создать экземпляр абстрактного класса.

```c#
// Ошибка: нельзя создать экземпляр абстрактного класса
Damageable damageable = new Damageable ();
```

Дочерний класс обязан реализовать все абстрактные члены родительского класса, за исключением, если дочерний класс тоже является абстрактным.

```c#
public abstract class Damageable {
    public abstract void Death ();
}

// Нет ошибки: дочерний класс абстрактный
public abstract class DamageableItem : Damageable {}

// Нет ошибки: метод переопределен
public class Player : Damageable {
    public override void Death () {
        // Do something...
    }
}

public class Enemy : Damageable {
    // Ошибка:
    // "Enemy" не реализует наследуемый абстрактный член "Damageable.Death()"
}
```

## Проблемы с абстрактными классами

В С++ не было ключевого слова **interface** и структуры, которая его поддерживала. В качестве интерфейсов использовались абстрактные классы. Поэтому абстрактные классы играли роль контрактов и в тоже время могли быть базовым классом для иерархии классов.

Минус абстрактного класса в том, что в него в любой момент можно добавить реализацию не подходившую по смыслу некоторым его наследникам.

пример

В С++ так и не появилась отдельная структура интерфейса, все еще используются абстрактные классы. В других языках добавили дополнительную структуру **interface**, которая поддерживала только контракты методов без возможности добавить реализацию. 

пример

Интерфейс гарантировал, что наследник реализует все его методы и что никто не сможет добавить лишнее поведение.

## Интерфейс

Интерфейс — это набор контрактов методов, которые не имеют и не могут иметь реализацию внутри интерфейса. В некоторых языках есть ключевое слово, чтобы помечать интерфейс — **interface**.

```c#
interface ISword {
    public void SetDamage ();
    public double GetDamage ();
}
```

**Контракт метода** — это название метода, аргументы с учётом их порядка и возвращаемое значение.

```c#
string GetFullName (string firstName, string lastName)
```

Интерфейс можно считать подвидом абстрактного класса.



## Зависимость классов

Абстрактный класс создавал сильную зависимость между классами, так как его изменение может повлиять на все его дочерние классы. 

Интерфейс пример более слабой зависимости. С одной стороны нужно реализовывать все методы, и если будет добавлен новый метод, его необходимо будет реализовать. С другой стороны добавить готовую реализацию в интерфейс нельзя, соответственно ожидать странное поведение от наследников не стоит.

В C# и Java нет множественного наследования для классов, но есть множественное наследование для интерфейсов.





## Примеры

Становясь рыцарем вы даете клятву, что будете смелым, верным и доблестным рыцарем. Так же с интерфейсами. Наследуясь от интерфейса вы клянётесь, что реализуете все методы и свойства, которые есть в интерфейсе. А вот с абстрактным классом вам и меч могут дать в придачу, кроме обязанностей.

Абстрактный класс — полуфабрикат, интерфейс — идея продукта.

На примере здания:

1. Если вам дают **абстрактный класс**, то могут дать уже частично готовое строение, но сказать, что двери вы обязаны сами приделать, такие какие вам удобны.
2. Если вам дают **интерфейс**, вам кратко описывают как дом должен по идеи выглядеть, а строите вы его уже сами.





Абстрактный класс используется для создания иерархии классов с похожим поведением.

Интерфейс используется для реализации контракта методов или свойств в классах, которые никак с друг другом не связаны.

Сигнатура метода — это название метода и входящие параметры.

```c#
GetFullName (string firstName, string lastName)
```



Суть интерфейса, чтобы обязать класс реализовать все его методы. Это дает гарантию, что класс реализовывает определенное поведение.

Зачем это нужно? К примеру:

> Операционная система UNIX требует, чтобы каждый драйвер устройства ввода/вывода реализовал пять стандартных функций: open, close, read, write и seek. Сигнатуры этих функций должны совпадать для всех драйверов.
>
> — Чистая архитектура. Роберт Мартин

То есть есть гарантия, что любое устройство ввода/вывода поддерживает определенное поведение, а вот как оно реализовано не так важно; нам не интересно как именно клавиатура или мышь считывают информацию, нам интересно, что они нам возвращают.

## C# 8.0

В новой версии C# появилась возможность добавлять реализацию в интерфейсы.

пример

## Итоги

Когда используют абстрактный класс:

1. Когда необходимо определить общее поведение для родственных объектов.
2. Когда все дочерние элементы, на всех уровнях, должны обладать базовым поведением. Если это поведение необходимо будет изменить, достаточно будет изменить базовый класс.
3. Когда необходимо предоставить шаблон класса, но предоставить пользователю самому частично его закончить.

Когда используют интерфейс:

1. Когда необходимо определить одинаковые методы для объектов, которые никак не связаны с друг другом.
2. Когда необходимо создать стабильный интерфейс взаимодействия с компонентом.
3. Чтобы снизить зависимость от конкретной реализации.
4. Чтобы позволить пользователям самим определять какая реализация им нужна.

