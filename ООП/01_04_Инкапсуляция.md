# Инкапсуляция

Два основных определения инкапсуляции:

> 1. Инкапсуляция - это языковая конструкция, позволяющая связать данные с методами, предназначенными для обработки этих данных.
> 2. Инкапсуляция - это механизм языка, позволяющий ограничить доступ одних компонентов программы к другим;
>
> [Wikipedia](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

Как правило инкапсуляцию понимают хуже всего. Это связанно с тем, что есть два определение и множество их трактовок. Еще хуже, когда инкапсуляцию сужают до обычного сокрытия данных.

Сокрытие является частью инкапсуляции, но задачи инкапсуляции шире обычного сокрытия данных. Поэтому называть инкапсуляцию сокрытием не совсем верно, хотя в задачи инкапсуляции входят задачи сокрытия данных.

> Инкапсуляция очерчивает круг связанных данных и функций. За пределами этого круга данные невидимы и доступны только некоторые функции. Воплощение этого понятия можно наблюдать в виде приватных членов данных и общедоступных членов-функций класса.
>
> — Роберт Мартин (Чистая Архитектура)

***Инкапсуляция решает проблему доступа к данным***. В некоторых языках программирования можно создавать глобальные поля, к которым могут обращаться все функции из любого места программы. В любой момент можно написать функцию, которая бы меняла значение поля в неподходящий момент, уследить за этим сложно. Это тоже самое, если бы некоторые органы человека были снаружи и любой прохожий мог их потрогать или нарушить их работу.

На помощь пришли объекты с их инкапсуляцией. Инкапсуляция позволяет объединить поля и функции в одном объекте, таким образом запретив случайный доступ к полям. Т.е. как бы объект является защитной обёрткой данных, а методы безопасным способом доступа к ним. Если с примером человека, то всё органы снова внутри тела и никто не может их потрогать напрямую.

Здесь конечно есть оговорки. К примеру человека можно разрезать и получить доступ к органам насильно. В программировании подобное позволяет делать **рефлексия** — получать доступ ко всем полям и методам во время выполнении приложения. Рефлексия хоть и является мощным инструментом, но нарушает инкапсуляцию. Но это скорее исключение. 

Сокрытие данных или методов происходит при помощи модификаторов доступа: **public**, **protected**, **private**, **internal**. Таким образом можно ограничить уровень доступа к полям и методам.

Придерживаясь инкапсуляции нельзя получить доступ к полям напрямую. Обращаться или менять состояние объекта можно **только через методы** (конструктор тоже является методом). **Состояние объекта** — это текущее значение всех полей объекта.

Инкапсуляция также **увеличивает уровень абстракции**, так как лишает нас нужды разбираться в реализации объекта. Инкапсуляция просто предоставляет интерфейс, с которым можно работать и нам не нужно знать, что там внутри. Т.е. превращает объект в черный ящик. В этот черный ящик можно передать какие-то данные (входные параметры), черный ящик производит с ними операции и возвращает нам результат, однако нам всё равно как он это делает.

# Сокрытие vs Инкапсуляция

## Пример сокрытия 

В примерах ниже данные и методы не объединены между собой. Данные User находятся в структуре, а методы находятся отдельно от неё на глобальном уровне. Структура User содержит два открытых поля. 

Стоит обратить внимание на то, что реализация создания новой структуры и получения полного имени скрыта внутри методов.

И вроде бы всё хорошо, до тех пор пока мы не решили вдруг изменить значение полей. В данном примере это не так страшно, выведенной имя просто будет устаревшим. Но бывают случаи, когда данные должны соответствовать определенному шаблону, к примеру: *имя не должно содержать больше 20 символов*. Можно написать отдельный метод, который будет принимать строку и проверять ее на соответствие шаблону. Но разработчик может не знать об этом методе или просто забыть его использовать. То есть нет согласованности данных и нельзя быть уверенным, что поле хранит верное значение, если его можно изменить из любой части приложения.

### Пример на псевдокоде

```pseudocode
struct User
	public string firstName
	public string lastName

// Глобальные функции
function CreateUser(string firstName, string lastName)
	User user
	user.firstName = firstName
	user.lastName = lastName
	return user

function GetFullName(User user)
	return user.firstName + " " + user.lastName

// Пример выполнения программы
function Start ()
	User user = CreateUser("Tony", "Stark")
	string userFullName = GetFullName(user)
	
	// Но мы решили изменить поля
    user.firstName = "John";
	user.lastName = "Huston";
	
	// И теперь на консоль выведится нерелавантное имя
	print(userFullName)
```

### Пример на C#

В C# нельзя объявить глобальную функцию, только методы внутри класса. Поэтому в данном примере создан статический класс, со статическими методами; так сказать — имитация глобальных функций.

```c#
public struct User
{
	public string firstName;
	public string lastName;
}

public static class UserManager
{
	public static User Create(string firstName, string lastName)
	{
		User user = new User();
		user.firstName = firstName;
		user.lastName = lastName;

		return user;
	}

	public static string GetFullName(User user)
	{
		return user.firstName + " " + user.lastName;
	}
}

class Program
{
    static void Main(string[] args)
    {
        User user = UserManager.Create("Tony", "Stark");
        string userFullName = UserManager.GetFullName(user);
        
        // Но мы решили изменить поля
        user.firstName = "John";
		user.lastName = "Huston";
        
        // И теперь на консоль выведится нерелавантное имя
        Console.WriteLine(userFullName);
    }
}
```

## Пример инкапсуляции

И чтобы решить проблемы доступа к данным, появился такая парадигма как **инкапсуляция**. Напомню, что она оборачивает данные и методы в один объект, и ограничивает доступ к данным.

В примере ниже, все поля и методы объединены в одном классе. Значение полей в объект передаются через конструктор, который по факту является обычным методом. Доступ к полям можно получить только через методы. 

По стандарту поля являются закрытыми (private).

Внутри методов доступ к данным происходит через ключевое слово ***this***, которое позволяет обращаться к полям текущего объекта. Получить доступ к данным извне напрямую нельзя. Это и есть пример инкапсуляции.

Если бы были дополнительные ограничения, вроде: *имя не должно содержать больше 20 символов*. Можно было бы внутри конструктора делать дополнительные проверки и выкидывать исключения, если данные не соответствуют правилам. А еще лучше создать метод **SetFirstName**, и внутри него проверять все правила для присваивания нового имени. 

### Пример на псевдокоде

```pseudocode
class User
	string firstName
	string lastName
	
	public constructor (string firstName, string lastName)
        this.firstName = firstName
        this.lastName = lastName
	
	// Методы доступа к полям
	public method GetFirstName ()
		return firstName
	
	public method GetLastName ()
		return lastName
	
    public method GetFullName(User user)
        return this.firstName + " " + this.lastName

// Пример выполнения программы
function Start ()
	User user = new User("Tony", "Stark")
	string userFullName = user.GetFullName()
	
	// Будет ошибка, так как у нас нет доступа к полям
    // user.firstName = "John";
	// user.lastName = "Huston";
	
	// На консоль выведится релевантное имя
	print(userFullName)
```

### Пример на C#

```c#
public class User 
{
    private string firstName;
    private string lastName;
    
    public User (string firstName, string lastName) 
    {
        this.firstName = firstName;
        this.lastName = lastName;
    }
    
    public string GetFirstName ()
    {
        return firstName;
    }
    
    public string GetLastName () 
    {
        return lastName;
    }
    
    public string GetFullName () 
    {
        return this.firstName + " " + this.lastName;
    }
}

class Program
{
	static void Main(string[] args)
	{
		User user = new User("Tony", "Stark");
		string userFullName = user.GetFullName();
        
        // Будет ошибка, так как у нас нет доступа к полям
        // user.firstName = "John";
        // user.lastName = "Huston";
        
        // На консоль выведится релевантное имя
		Console.WriteLine(userFullName);
	}
}
```

## Итоги

1. Инкапсуляция решает проблему глобальных переменных при помощи объединения методов и данных в одну сущность, и ограничивает доступ к данным.
2. Сокрытие — это одна из задач инкапсуляции. Но само по себе сокрытие данных инкапсуляцией не является. Инкапсуляцию неверно называть сокрытием, так как ее задачи выходят за рамки простого сокрытия данных.
3. Инкапсуляция предоставляет интерфейс для работы с данными в виде методов.
4. Инкапсуляция запрещает обращаться к данным на прямую. Обращаться к данным можно только через методы.
5. Инкапсуляцию можно сравнить с черным ящиком: передаешь данные в черный ящик, он производит над ними операции и возвращает результат при помощи методов. Она лишает нас лишних деталей реализации и упрощает работу с объектом.

## Источники

1. [Clean Architecture - Robert C. Martin - Book](https://www.amazon.co.uk/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164)
2. [ООП. Инкапсуляция и сокрытие данных - Website](https://pro-prof.com/forums/topic/oop-encapsulation-and-hiding-data)
3. [Учебник: объектно-ориентированное программирование - Website](https://pro-prof.com/archives/5355)
4. [Инкапсуляция (программирование) - Wikipedia](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))